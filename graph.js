/////////////////////////////////////////////////////
//////// Dynamic d3 graph displayed to user /////////
/////////////////////////////////////////////////////

// set up the dimensions of the chart
const dims = {
    height: 300,
    width: 300,
    radius: 150
}

// determine the center of my chart
const cent = {
    x: (dims.width / 2 + 5),
    // chart cntr -^     ^-- 5px to right
    y: (dims.height / 2 + 5)
}

// create the SVG container for the graph
const svg = d3.select('.canvas')
    .append('svg')
    .attr('width', dims.width + 150)
    // add space for legend -----^
    .attr('height', dims.height + 150)

// create a group w/ graph elements and append
const graph = svg.append('g')
    // append group ----^     ^-- g for group
    // transform group to translate it to center
    .attr('transform', `translate(${cent.x}, ${cent.y})`);

/////////////////////////////////////////////////////
////////// generate our pie graph angles ////////////
/* this is a function that will receive data (often,
    in the form of an array), not sort it, and then
    evaluate each data element to determine the
    correct angle for my pie chart */
/////////////////////////////////////////////////////
const pie = d3.pie()
    // tell d3 don't sort angles based on size
    .sort(null)
    // make angles based on cost property
    .value(d => d.cost);
    //     ^--- d for data object

/////////////////////////////////////////////////////
////////// generate our pie graph slices ////////////
/////////////////////////////////////////////////////

const arcPath = d3.arc()
    // how far out the slices go on the canvas
    .outerRadius(dims.radius)
    // used to create a donut chart
    .innerRadius(dims.radius / 2);

/////////////////////////////////////////////////////
//////// listen to the Firestore database ///////////
/////////////////////////////////////////////////////
var data = [];

// function that fires when Firestore sends us a new data snapshot
const update = (data) => {
    console.log(data);
}

// onSnapshot() listens to the collection and does something with each response
db.collection('expenses').onSnapshot(res => {

    res.docChanges().forEach(change => {
        // iterate over the change data and create a new object called doc for each one that also includes the id property generated by Firebase
        const doc = { ...change.doc.data(), id: change.doc.id };

        // detect what kind of change has happened to the Firestore and trigger actions accordingly
        switch (change.type) { 
            // if something was added to the collection, add it to the data array
            case 'added':
                data.push(doc);
                break;
            // if modified, find the index of the doc in the data array and replace it with the new version
            case 'modified':
                const index = data.findIndex(item => item.id == doc.id);
                data[index] = doc;
                break;
            // if something was removed, replace the data array with a new one after filtering out the removed one using its unique id
            case 'removed':
                data = data.filter(item => item.id !== doc.id);
                break;
            default:
                break;
        }

    })

    // call update() when data received
    update(data);

})
    